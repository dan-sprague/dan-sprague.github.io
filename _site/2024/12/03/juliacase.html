<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>The Case for Julia in Computational Biology | Dan Sprague</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="The Case for Julia in Computational Biology" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Stories of variation around a mean." />
<meta property="og:description" content="Stories of variation around a mean." />
<link rel="canonical" href="http://localhost:4000/2024/12/03/juliacase" />
<meta property="og:url" content="http://localhost:4000/2024/12/03/juliacase" />
<meta property="og:site_name" content="Dan Sprague" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2024-12-03T23:00:00-05:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="The Case for Julia in Computational Biology" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-12-03T23:00:00-05:00","datePublished":"2024-12-03T23:00:00-05:00","description":"Stories of variation around a mean.","headline":"The Case for Julia in Computational Biology","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2024/12/03/juliacase"},"url":"http://localhost:4000/2024/12/03/juliacase"}</script>
<!-- End Jekyll SEO tag -->


<meta
  name="keywords"
  content="" />

<link rel="shortcut icon" href="/favicon.ico" />
<link rel="apple-touch-icon" href="/favicon.ico" />
<link
  rel="alternate"
  type="application/rss+xml"
  title="Dan Sprague - Stories of variation around a mean."
  href="/feed.xml" />
<link
  rel="stylesheet"
  type="text/css"
  href="/assets/css/base.css" />
<link
  rel="stylesheet"
  type="text/css"
  href="/assets/css/highlight.css" />

<!--[if lt IE 9]>
  <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->



<script
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"
  async>
</script>

<style>
.math-container {
  max-width: 100%;
  overflow-x: auto;
  overflow-y: hidden;
  -webkit-overflow-scrolling: touch;
  padding: 10px 0;
  margin: 1em 0;
}

.math-container::-webkit-scrollbar {
  height: 8px;
}

.math-container::-webkit-scrollbar-thumb {
  background: #ccc;
  border-radius: 4px;
}

.math-container::-webkit-scrollbar-track {
  background: #f1f1f1;
}

.inline-math-container {
  display: inline-block;
  max-width: 100%;
  overflow-x: auto;
  overflow-y: hidden;
  -webkit-overflow-scrolling: touch;
  vertical-align: middle;
  padding: 0 2px;
}

.inline-math-container::-webkit-scrollbar {
  height: 4px;
}

.inline-math-container::-webkit-scrollbar-thumb {
  background: #ccc;
  border-radius: 2px;
}
</style>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$', '$'], ['\\(', '\\)']],
    displayMath: [['$$', '$$'], ['\\[', '\\]']],
    processEscapes: true
  },
  CommonHTML: {
    scale: 100,
    minScaleAdjust: 100,
    linebreaks: { automatic: false }
  },
  "HTML-CSS": {
    linebreaks: { automatic: false }
  },
  SVG: {
    linebreaks: { automatic: false }
  }
});

MathJax.Hub.Queue(function() {
  
  var mathElements = document.querySelectorAll('.MathJax, .MathJax_CHTML, .MathJax_SVG');
  
  mathElements.forEach(function(element) {
    var isDisplayMode = element.parentNode.className.indexOf('display') !== -1;
    
    var container = document.createElement('div');
    container.className = isDisplayMode ? 'math-container' : 'inline-math-container';
    
    element.parentNode.insertBefore(container, element);
    container.appendChild(element);
    
    element.style.fontSize = '100%';
  });
});
</script>



<script src="/assets/scripts/jekyllpaper.js" async></script>
<script
  src="https://unpkg.com/mermaid@8.5.1/dist/mermaid.min.js"
  onload="javascript:loadMermaid();"
  async>
</script>


  </head>
  <body>
    <div class="container-wrapper">
      <header class="container-header">
        <div class="header-info">
  <div class="header-info-name">Dan Sprague</div>
  <div class="header-info-desc">Stories of variation around a mean.</div>
</div>
<nav class="header-nav">
  <ul class="header-main-nav">
    
    <li class="header-main-nav-item">
      <a href="/">
        
          home
        
      </a>
    </li>
    
    <li class="header-main-nav-item">
      <a href="/categories">
        
          categories
        
      </a>
    </li>
    
    <li class="header-main-nav-item">
      <a href="/projects">
        
          projects
        
      </a>
    </li>
    
    <li class="header-main-nav-item">
      <a href="/photography">
        
          photography
        
      </a>
    </li>
    
  </ul>
</nav>
      </header>
      <main class="container-main">
        <article class="container-post">
  <div class="post-title">
    <h1>The Case for Julia in Computational Biology</h1>
  </div>
  
  <div class="post-author print-post-author">
    <span>Dan Sprague</span>
  </div>
  
  <div class="post-content">
    <p><br /></p>

<h2 id="table-of-contents">Table of Contents</h2>

<ul>
  <li><a href="#project-management-and-reproducibility">Project Management and Reproducibility</a></li>
  <li><a href="#text-processing">Text Processing</a></li>
  <li><a href="#fast-and-easy-multithreading">Fast and Easy Multithreading</a></li>
  <li><a href="#functions-are-center-stage">Functions Are Center Stage</a></li>
</ul>
<hr />

<p><br /></p>

<p>Why Julia? Python excels as a general purpose programming language and as a wrapper for neural network implementations, whereas R excels at data analysis, plotting, statistics, and for its robust library of bioinformatics packages. What is missing from the computational biology toolkit is a language that is easy to write, read, while maximizing performance on numerical and sequence based data. This is the niche that Julia fills.<br /><br /></p>

<h2 id="native-project-management-and-reproducibility">Native Project Management and Reproducibility</h2>
<p><br />
In the sciences, reproducibility and organization are perhaps the most important component of good research. This is generally true for most applications – which is why languages like Rust and Julia have robust environment management built directly into the language as a core feature.<br /><br /></p>

<p>For a scientific paper or research project, the following organizational scheme is easy to obtain:<br /></p>

<ul>
  <li>Project
    <ul>
      <li>Package # generalized code for entire project
        <ul>
          <li>Manifest.toml</li>
          <li>Project.toml</li>
          <li>src/</li>
          <li>tests/</li>
          <li>README.md</li>
          <li>…</li>
        </ul>
      </li>
      <li>Figure 1
        <ul>
          <li>Manifest.toml</li>
          <li>Project.toml</li>
          <li>fig1.jl</li>
          <li>data/</li>
        </ul>
      </li>
      <li>Figure 2
        <ul>
          <li>Manifest.toml</li>
          <li>Project.toml</li>
          <li>fig2.jl</li>
          <li>data/</li>
        </ul>
      </li>
      <li>…</li>
    </ul>
  </li>
</ul>

<p>Dependency management is automatic, with no overhead other than the initial creation of a project directory via <code class="language-plaintext highlighter-rouge">Pkg.generate("Project")</code>. To truly compartmentalize one’s work in Python between projects, or even specific analyses within a project, would be practically difficult or impossible. In Julia: enter the project directory and launch Julia. The correct environment with all its dependencies will be loaded from there. The base Julia environment is kept clean.<br /><br /></p>

<h2 id="text-processing">Text Processing</h2>
<p><br />
Computational biologists and bioinformaticians often work with text-based data. Because Julia is JIT compiled and Chars are a first-class type, string data can be processed extremely quickly. BioSequences.jl has efficient minimal representations for biological characters that are intuitive and simple to operate on. For bioinformaticians, this has serious implications: rather than writing difficult to maintain code in C++ or Rust, it is possible to develop a short Julia program (with python-esque syntax) to analyze millions of biological sequences with speed that is comparable to C.<br /><br /></p>

<h3 id="example">Example</h3>
<p><br />
Take a simple program to generate 100M short DNA sequences and check for palindromes. While DNA and RNA can and should be more efficiently represented (Julia has a package that implements efficient representations of DNA/RNA/Protein sequences), lets assume that we are simply optimizing for readability and implementation time.<br /><br /></p>

<h4 id="python">Python</h4>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">time</span>


<span class="n">complement</span> <span class="o">=</span> <span class="p">{</span><span class="s">'A'</span><span class="p">:</span> <span class="s">'T'</span><span class="p">,</span> <span class="s">'C'</span><span class="p">:</span> <span class="s">'G'</span><span class="p">,</span> <span class="s">'G'</span><span class="p">:</span> <span class="s">'C'</span><span class="p">,</span> <span class="s">'T'</span><span class="p">:</span> <span class="s">'A'</span><span class="p">}</span>

<span class="k">def</span> <span class="nf">ceildiv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">return</span> <span class="o">-</span><span class="p">(</span><span class="n">a</span> <span class="o">//</span> <span class="o">-</span><span class="n">b</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">random_dna_sequence</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="n">letters</span> <span class="o">=</span> <span class="p">[</span><span class="s">"A"</span><span class="p">,</span> <span class="s">"T"</span><span class="p">,</span> <span class="s">"C"</span><span class="p">,</span> <span class="s">"G"</span><span class="p">]</span>
    <span class="k">return</span> <span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">random</span><span class="p">.</span><span class="n">choice</span><span class="p">(</span><span class="n">letters</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">generate_dna_sequences</span><span class="p">(</span><span class="n">count</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">random_dna_sequence</span><span class="p">(</span><span class="n">random</span><span class="p">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">count</span><span class="p">)]</span>

<span class="k">def</span> <span class="nf">is_palindrome</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ceildiv</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">),</span><span class="mi">2</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">complement</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]]:</span>
                <span class="k">return</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="bp">True</span> 

<span class="c1"># Generate 1 million random DNA strings
</span><span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="n">time</span><span class="p">()</span>
<span class="n">dna_sequences</span> <span class="o">=</span> <span class="n">generate_dna_sequences</span><span class="p">(</span><span class="mi">100_000_000</span><span class="p">)</span>
<span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="n">time</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Sequence Generation Time: "</span><span class="p">,</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span>

<span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="n">time</span><span class="p">()</span>
<span class="n">results</span> <span class="o">=</span> <span class="p">[</span><span class="n">is_palindrome</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">dna_sequences</span><span class="p">]</span>
<span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="n">time</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Palindrome check time: "</span><span class="p">,</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span>

</code></pre></div></div>

<p>Sequence generation took <code class="language-plaintext highlighter-rouge">246.97s</code> and palindrome checking took <code class="language-plaintext highlighter-rouge">12.87s</code>.<br /></p>

<h4 id="julia">Julia</h4>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">const</span> <span class="n">complement</span> <span class="o">=</span> <span class="kt">Dict</span><span class="x">(</span><span class="sc">'A'</span><span class="o">=&gt;</span><span class="sc">'T'</span><span class="x">,</span> <span class="sc">'T'</span><span class="o">=&gt;</span><span class="sc">'A'</span><span class="x">,</span> <span class="sc">'C'</span><span class="o">=&gt;</span><span class="sc">'G'</span><span class="x">,</span> <span class="sc">'G'</span><span class="o">=&gt;</span><span class="sc">'C'</span><span class="x">);</span>

<span class="k">function</span><span class="nf"> is_palindrome</span><span class="x">(</span><span class="n">s</span><span class="o">::</span><span class="kt">Vector</span><span class="x">{</span><span class="kt">Char</span><span class="x">})</span><span class="o">::</span><span class="kt">Bool</span>
    <span class="n">isodd</span><span class="x">(</span><span class="n">length</span><span class="x">(</span><span class="n">s</span><span class="x">))</span> <span class="o">&amp;&amp;</span> <span class="k">return</span> <span class="nb">false</span>

    <span class="nd">@inbounds</span> <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="o">:</span><span class="n">cld</span><span class="x">(</span><span class="n">length</span><span class="x">(</span><span class="n">s</span><span class="x">),</span><span class="mi">2</span><span class="x">)</span>
        <span class="n">s</span><span class="x">[</span><span class="n">i</span><span class="x">]</span> <span class="o">!=</span> <span class="n">complement</span><span class="x">[</span><span class="n">s</span><span class="x">[</span><span class="k">end</span><span class="o">-</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="x">]]</span> <span class="o">&amp;&amp;</span> <span class="k">return</span> <span class="nb">false</span>
    <span class="k">end</span>

    <span class="nb">true</span> 
<span class="k">end</span>



<span class="k">function</span><span class="nf"> random_dna_sequence</span><span class="x">(</span><span class="n">n</span><span class="o">::</span><span class="kt">Int</span><span class="x">)</span><span class="o">::</span><span class="kt">Vector</span><span class="x">{</span><span class="kt">Char</span><span class="x">}</span>
    <span class="n">rand</span><span class="x">([</span><span class="sc">'A'</span><span class="x">,</span><span class="sc">'T'</span><span class="x">,</span><span class="sc">'C'</span><span class="x">,</span><span class="sc">'G'</span><span class="x">],</span><span class="n">n</span><span class="x">)</span>
<span class="k">end</span>


<span class="nd">@time</span> <span class="n">nucs</span> <span class="o">=</span> <span class="n">map</span><span class="x">(</span><span class="n">random_dna_sequence</span><span class="x">,</span> <span class="n">rand</span><span class="x">(</span><span class="mi">4</span><span class="o">:</span><span class="mi">10</span><span class="x">,</span><span class="kt">Int</span><span class="x">(</span><span class="mf">1e8</span><span class="x">)))</span>

<span class="nd">@time</span> <span class="n">result</span> <span class="o">=</span> <span class="n">is_palindrome</span><span class="o">.</span><span class="x">(</span><span class="n">nucs</span><span class="x">)</span>


</code></pre></div></div>

<p>Sequence generation took <code class="language-plaintext highlighter-rouge">21.52s</code> and palindrome checking took <code class="language-plaintext highlighter-rouge">1.82s</code>. There are several things to note about the implementations here. The first is that Julia required no imports. Second, Julia’s <code class="language-plaintext highlighter-rouge">@time</code> macro saves a tremendous amount of repetitious code. Third, the <code class="language-plaintext highlighter-rouge">is_palindrome</code> function can be broadcasted over the <code class="language-plaintext highlighter-rouge">nucs</code> vector with the <code class="language-plaintext highlighter-rouge">.</code> syntax. This is despite being a handrolled function, something which is not really feasible in Python. Finally, these functions are so efficient that very little is gained very multithreading. Larger relative improvements in speed would be expected for more complex operations, such as sequence alignment and mapping.</p>

<h2 id="fast-and-easy-multithreading">Fast and Easy Multithreading</h2>
<p><br />
Parallelism and broadcasting in Python are a major weakness of the language, and this is a problem because many if not most bioinformatics workflows are independently parallel. This is an area where Julia truly shines compared to Python. Combined with increased text-based processing speed and native numerical computation, this is when Julia really begins to shine.<br /><br /></p>

<p>In Julia, threading over a loop is as simple as:<br /><br /></p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="n">Base</span><span class="o">.</span><span class="n">Threads</span> <span class="c">#brings Threads functions into the namespace, does not need to imported</span>
  
<span class="n">n</span> <span class="o">=</span> <span class="mi">10_000_000</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">zeros</span><span class="x">(</span><span class="kt">Float64</span><span class="x">,</span> <span class="n">n</span><span class="x">)</span>  
<span class="nd">@threads</span> <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="o">:</span><span class="n">n</span>
  <span class="n">result</span><span class="x">[</span><span class="n">i</span><span class="x">]</span> <span class="o">=</span> <span class="n">sqrt</span><span class="x">(</span><span class="n">i</span><span class="x">)</span>
<span class="k">end</span>
</code></pre></div></div>
<p><br /><br /></p>

<h2 id="elegant-machine-learning">Elegant Machine Learning</h2>
<p><br />
Julia’s syntax, large scientific and numerical ecosystem, and native support results in elegant code for statistical modeling and machine learning that does not depend on DSLs. Below is a simple program that uses two of Julia’s most powerful packages to yield a MLE for a Gamma distributed sample in only a few lines of code. <br /><br /></p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="n">Distributions</span>
<span class="k">using</span> <span class="n">Optim</span>  

<span class="k">function</span><span class="nf"> f</span><span class="x">(</span><span class="n">α</span><span class="x">,</span><span class="n">β</span><span class="x">,</span><span class="n">x</span><span class="x">)</span> <span class="c"># likelihood function</span>
  <span class="o">-</span><span class="n">sum</span><span class="x">(</span><span class="n">logpdf</span><span class="x">(</span><span class="n">Gamma</span><span class="x">(</span><span class="n">exp</span><span class="x">(</span><span class="n">α</span><span class="x">),</span><span class="n">exp</span><span class="x">(</span><span class="n">β</span><span class="x">)),</span> <span class="n">x</span><span class="x">))</span>
<span class="k">end</span>
 
<span class="n">x</span> <span class="o">=</span> <span class="n">rand</span><span class="x">(</span><span class="n">Gamma</span><span class="x">(</span><span class="mf">2.0</span><span class="x">,</span><span class="mf">1.5</span><span class="x">),</span><span class="mi">500</span><span class="x">)</span> <span class="c"># data  </span>
<span class="n">θ_init</span> <span class="o">=</span> <span class="x">[</span><span class="mf">1.0</span><span class="x">,</span><span class="mf">1.0</span><span class="x">]</span>
<span class="n">θ_mle</span><span class="o">=</span> <span class="n">Optim</span><span class="o">.</span><span class="n">optimize</span><span class="x">(</span><span class="n">θ</span> <span class="o">-&gt;</span> <span class="n">f</span><span class="x">(</span><span class="n">θ</span><span class="o">...</span><span class="x">,</span><span class="n">x</span><span class="x">),</span> <span class="n">θ_init</span><span class="x">)</span> <span class="c"># … is the “splat” operator in Julia </span>
</code></pre></div></div>
<p><br /><br />
Line 11 creates a closure such that the optimize routine only performs optimization on the estimated parameters captured in the theta vector. This is a common problem in likelihood functions, as both parameters and data are necessary arguments. Julia treats functions as first-class types, making anonymous functions, closures, and other functional programming paradigms a natural part of the language.<br /><br /></p>

<p>In Julia, it is possible to design custom networks using native Julia code. In early project development, this often helps to quickly iterate on ideas. Significant time is saved from ensuring you understand the behavior of every function in Pytorch/Jax/Tensorflow, which requires substantial upfront time investment.<br /><br /></p>

  </div>
  <div class="post-info">
    <div class="post-date">
      Written on 
      2024-12-03
      
        ,
        updated at 
        2024-12-04
      
      .
    </div>
    
    <div class="post-author">
      Author: Dan Sprague
    </div>
    
    <div class="post-categories">
      <span>Categories: </span>
      
      <a 
        href="/categories#Julia"
        class="post-category">
        Julia
      </a>
      
    </div>
    <div class="post-tags">
      <span>Tags: </span>
      
    </div>
    <div class="post-other">
      
      <div>
        <span>
          Next: 
        </span>
        <a href="/2025/02/01/llmthinking">
          Thinking Machines
        </a>
      </div>
      
      
    </div>
    
  </div>
</article>

      </main>
      <footer class="container-footer">
        <div class="footer-copyright">
  <span class="footer-copyright-text float-left">
    Copyright &copy; 2025. example.com.
  </span>
  <span class="footer-copyright-text float-right">
    Powered by <a href="https://jekyllrb.com/">Jekyll</a>, themed by <a href="https://github.com/ghosind/Jekyll-Paper-Github">Jekyll-Paper-Github</a>.
  </span>
</div>

      </footer>
    </div>
  </body>
</html>
